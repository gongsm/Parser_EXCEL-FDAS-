import re
import time
import itertools

from lxml import etree

class Bunch(object):
    def __init__(self, **kwds):
        self.__dict__.update(kwds)
        
def parseAlert(fullxmlname):
    ''' 
    parse alert definition, which generated by FDASGen tool chain, and create a T/F table for CD or MC/DC
    Parameters: 
        fullxmlname: full path of the xml file 
    Returns: 
        T/F table in Excel format
    '''
    
    xmltree = etree.parse(fullxmlname)
    root = xmltree.getroot()
    
    alerts = []
    #logics = []
    #rpnlist = []
    
    for x in root.iterfind("alerts/alert"):
        alertid        = x.attrib['alertId']
        sourceid       = x.attrib['sourceId']
        inhibit        = x.attrib['flightPhaseInhibit']

        logicsource = x.find("logicsource")
        logic = x.find("logic")
        #logics.append(logicsource.text.strip())
        #rpnlist.append(logic.text.strip())
        alerts.append(Bunch(sourceid=sourceid, 
                            alertid=alertid, 
                            inhibit=inhibit, 
                            logic=logicsource.text.strip(), 
                            booleanlogic=None, 
                            rpn=logic.text.strip(), 
                            coupledconditions=None, 
                            conditions=None, 
                            maskpairdict=None, 
                            alphabet=None, 
                            truthtable=[], 
                            falsetable=[] ))
    
    return alerts

def genMCDCTable(rpn):
    OP = {
          'gt': ' > ',
          'ge': ' >= ',
          'lt': ' < ',
          'le': ' <= ',
          'add': ' + ',
          'sub': ' - ',
          'mul': ' * ',
          'div': ' / ',
          }

    def deep(tokens):
        elem = tokens.pop()

        if elem.startswith('.td'):
            elem = tokens.pop()

        if elem == '.not':
            elem = tokens.pop() + ' == 0'
            
        if elem == '.eq':
            n = tokens.pop()
            p = tokens.pop()
            elem = elem.replace('.eq', p + ' == ' + n)
        
        if elem == '.fuminus':
            n = tokens.pop()
            elem = '-' + n
        
        if elem[2:] in OP.keys():
            rside = tokens.pop()
            if rside == '.fuminus':
                n = tokens.pop()
                rside = '-' + n

            lside = tokens.pop()
            if lside == '.fuminus':
                n = tokens.pop()
                lside = '-' + n
            
            elem = lside + OP[elem[2:]] + rside
            
        if elem.startswith('.active'):
            activities = tokens.pop()
            for i in range(int(activities)):
                elem = elem + ' ' + tokens.pop()

        if elem == '.or' or elem == '.and' or elem == '.xor':
            rtlist, rflist = deep(tokens)
            ltlist, lflist = deep(tokens)
            if elem == '.or':
                return mergeResultOr(ltlist, lflist, rtlist, rflist)
            elif elem == '.and':
                return mergeResultAnd(ltlist, lflist, rtlist, rflist)
            elif elem == '.xor':
                return mergeResultXor(ltlist, lflist, rtlist, rflist)
            else:
                print "Unknown element %s" % elem
                return
        else:
            return [True], [False]
          
    def mergeResultOr(h_tlist, h_flist, r_tlist, r_flist):
        _t = []
        _f = []
        
        if len(h_flist) > 0:
            fh = h_flist[0]
            for tr in r_tlist:
                if (fh, tr) not in _t:
                    _t.append((fh, tr))
            for fr in r_flist:
                if (fh, fr) not in _f:
                    _f.append((fh, fr))

        if len(r_flist) > 0:
            fr = r_flist[0]
            for th in h_tlist:
                if (th, fr) not in _t:
                    _t.append((th, fr))
            for fh in h_flist:
                if (fh, fr) not in _f:
                    _f.append((fh, fr))
        
        return _t, _f

    def mergeResultAnd(h_tlist, h_flist, r_tlist, r_flist):
        _t = []
        _f = []
        
        if len(h_tlist) > 0:
            th = h_tlist[0]
            for fr in r_flist:
                if (th, fr) not in _f:
                    _f.append((th, fr))
            for tr in r_tlist:
                if (th, tr) not in _t:
                    _t.append((th, tr))

        if len(r_tlist) > 0:
            tr = r_tlist[0]
            for fh in h_flist:
                if (fh, tr) not in _f:
                    _f.append((fh, tr))
            for th in h_tlist:
                if (th, tr) not in _t:
                    _t.append((th, tr))
        
        return _t, _f
    
    def mergeResultXor(h_tlist, h_flist, r_tlist, r_flist):
        _t = []
        _f = []
        
        for th in h_tlist:
            for fr in r_flist:
                if (th, fr) not in _f:
                    _f.append((th, fr))
            for tr in r_tlist:
                if (th, tr) not in _t:
                    _t.append((th, tr))

        for tr in r_tlist:
            for fh in h_flist:
                if (fh, tr) not in _f:
                    _f.append((fh, tr))
            for th in h_tlist:
                if (th, tr) not in _t:
                    _t.append((th, tr))
        
        return _t, _f
    
    tokens = rpn.strip().split()
    return deep(tokens)

def removeduplicate(seq):
    seen = set()
    seen_add = seen.add
    return [x for x in seq if not (x in seen or seen_add(x))]            

def findMasking(alphabetexpr):
    maskpairdict = {}
    
    varlist = getvars(alphabetexpr)
    uniquevarlist = removeduplicate(varlist)
    coupledvarlist = getCoupledCondition(varlist)
    
    foundmaskdict = {}
    
    for pair in re.findall(r'[A-Z]+\W*and\W*[A-Z]+|[A-Z]+\W*or\W*[A-Z]+',alphabetexpr):
        for var in coupledvarlist:
            (elem1, logic, elem2) = pair.split(' ')
            if var == elem1:
                maskvar = elem2
            elif var == elem2:
                maskvar = elem1
            else:
                continue
            
            if foundmaskdict.has_key(var):
                if maskvar in foundmaskdict[var]:
                    raise Exception, "Repeated expression."
                foundmaskdict[var].append(maskvar)
            else:
                foundmaskdict[var] = [maskvar]
            
            if maskpairdict.has_key(uniquevarlist.index(var)):
                maskpairdict[uniquevarlist.index(var)].append(Bunch(idx=uniquevarlist.index(maskvar), logic=logic))
            else:
                maskpairdict[uniquevarlist.index(var)] = [Bunch(idx=uniquevarlist.index(maskvar), logic=logic)]
    
    return maskpairdict
    
def getCoupledCondition(varlist):
    res = []
    for var in varlist:
        if varlist.count(var) > 1 and var not in res:
            res.append(var)
    return res

def list_duplicates_of(seq,item):
    start_at = -1
    locs = []
    while True:
        try:
            loc = seq.index(item,start_at+1)
        except ValueError:
            break
        else:
            locs.append(loc)
            start_at = loc
    return locs

def canonicalize(expr):
    REPLACEMENTS = {
       'Out = ' : '',
       'Out= ' : '',
       'Out=' : '',
       'OUT = ' : '',
       'Out =' : '',
       ' &amp;&amp; ' : ' and ',
       '||' : 'or',
       '&&' : 'and',
       '^^': '!=',
       'xor': '!=',
       '!' : 'not ',
    }

    expr = re.sub('|'.join(re.escape(sym) for sym in REPLACEMENTS.keys()), lambda sym: REPLACEMENTS[sym.group(0)], expr).strip()
    varlist = getvars(expr)
    uniquevars = removeduplicate(varlist)
    alphabetvars = map(lambda n: chr((n-65)%26+65)*((n-65)/26+1), range(65, 65+len(uniquevars))) 

    exprdict = dict(zip(uniquevars, alphabetvars))
    for k, v in exprdict.iteritems():
        expr = expr.replace(k, v)

    alphabetlist = map(lambda n: n, varlist)
    for idx in range(len(alphabetlist)):
        alphabetlist[idx] = exprdict[alphabetlist[idx]]
        
    #expr = replacebinary(expr)
    
    coupledconditions = {}
    for uniquevar in uniquevars:
        indexlist = list_duplicates_of(varlist, uniquevar)
        if len(indexlist) > 1:
            coupledconditions[uniquevar] = indexlist

    return expr, alphabetvars, coupledconditions, varlist, alphabetlist

def replacebinary(expr):
    for binaryexpr in removeduplicate(re.findall(r'[0-9]+b', expr)): 
        expr = expr.replace(binaryexpr, str(int(binaryexpr[:-1], 2)))
    return expr
                  
def getvars(expr):
    return list(re.findall(r"\([A-Za-z0-9_]+\W*>[=]*\W*[A-Za-z_0-9.-]+\)|\([A-Za-z0-9_]+\W*<[=]*\W*[A-Za-z_0-9.-]+\)|\([A-Za-z0-9_]+\W==\W[0-9]+[b]*\)|\bActive\W*\([A-Za-z0-9_-]+[\s,A-Za-z0-9_-]*\)|\bInval\([A-Z][A-Za-z0-9_-]*\)?|[A-Z][A-Za-z0-9_-]*", expr))
                  
def findMCDCPair(tlist, flist, maskdict):
    mcdcTlist = []
    mcdcFlist = []
    pairfound = []

    # mask the coupled conditions
    for k, v in maskdict.iteritems():
        for notmask in v:
            for t in tlist:
                candidatefound = True
                for mask in v:
                    if notmask.idx == mask.idx:
                        continue

                    if mask.logic == 'and' and t[mask.idx] != False:
                        candidatefound = False
                        break
                    if mask.logic == 'or' and t[mask.idx] != True:
                        candidatefound = False
                        break

                if candidatefound:
                    tcopy = map(lambda n: n, t)
                    tcopy[k] = not tcopy[k]
            
                    if tcopy in flist:
                        if t not in mcdcTlist:
                            mcdcTlist.append(t)
                        if tcopy not in mcdcFlist:
                            mcdcFlist.append(tcopy)
                        break

            if candidatefound == False:
                print "No MCDC candidate found"

    # go through the unique condition variable list
    for idx in range(len(tlist[0])):
        if idx in maskdict.keys():
            # already done
            continue
        # go through the truth table
        for t in tlist:
            tcopy = map(lambda n: n, t)
            tcopy[idx] = not tcopy[idx]

            if tcopy in flist:
                if t not in mcdcTlist:
                    mcdcTlist.append(t)
                if tcopy not in mcdcFlist:
                    mcdcFlist.append(tcopy)
                break
            
    return mcdcTlist, mcdcFlist
            
def genTruthTableBrutal(exprnorm, uniquevars, alphabetlist, maskdict):
    print time.strftime('Start: %H:%M:%S')

    NO_GLOBALS = {'__builtins__': {}}
    tlist = []
    flist = []

    for vals in itertools.product([True, False], repeat=len(uniquevars)):
        locals = dict(zip(uniquevars, vals))
        if eval(exprnorm, NO_GLOBALS, locals):
            tlist.append(list(vals))
        else:
            flist.append(list(vals))
        #print('\t'.join([str(v) for v in vals] + [str(result)]))
    #print "True"
    #print tlist
    #print "False"
    #print flist
    print time.strftime('Finish combination: %H:%M:%S')
    mcdctlist, mcdcflist = findMCDCPair(tlist, flist, maskdict)
    print time.strftime('Finish MCDC pair: %H:%M:%S')

    restlist = []
    for t in mcdctlist:
        template = map(lambda n: n, alphabetlist)
        for idx in range(len(template)):
            template[idx] = t[uniquevars.index(template[idx])]
        restlist.append(template)

    resflist = []
    for f in mcdcflist:
        template = map(lambda n: n, alphabetlist)
        for idx in range(len(template)):
            template[idx] = f[uniquevars.index(template[idx])]
        resflist.append(template)
        
    return restlist, resflist
    
def pretyprint(tflist, res):
    if type(tflist) is bool:
        res.append(tflist)
        return

    for tf in tflist:
        pretyprint(tf, res)
        
def listprint(l):
    res = []
    for e in l:
        op=[]
        pretyprint(e, op)
        #print op
        res.append(op)
        
    return res
    
def main(filename):
    alerts = parseAlert(filename)
    
    for alert in alerts:
        print alert.alertid
        print alert.logic
        if '.td' in alert.rpn:
            print 'TD function ignored'
            alert.conditions = [alert.logic]
            alert.booleanlogic = alert.logic
            alert.alphabet = [alert.logic]
            continue
        exprnorm, uniquevars, coupledconditions, varlist, alphabetlist = canonicalize(alert.logic)
        alert.conditions = varlist
        alert.booleanlogic = exprnorm
        alert.alphabet = alphabetlist
        alert.coupledconditions = coupledconditions
        print alert.logic
        print exprnorm
        if coupledconditions:
            maskdict = findMasking(exprnorm)
            alert.maskdict = maskdict
            tlist, flist = genTruthTableBrutal(exprnorm, uniquevars, alphabetlist, maskdict)
            alert.truthtable = tlist
            alert.falsetable = flist
        else:
            tlist, flist = genMCDCTable(alert.rpn)

            tprintable = listprint(tlist)
            fprintable = listprint(flist)
            
            print alert.alertid
            print tprintable
            print fprintable
            
            for t in tprintable:
                alert.truthtable.append(t) 
            for f in fprintable:
                alert.falsetable.append(f) 
    
    return alerts

if __name__ == '__main__':
    
    expr313 = 'Out = (!LEFT_ENG_FIRE_EXT_SYS_ARMED) &amp;&amp; (!RIGHT_ENG_FIRE_EXT_SYS_ARMED) &amp;&amp; \
                    ((TD(0.2,((A1_ENG_BOT_1_LOW_PRESSURE &amp;&amp; A2_ENG_BOT_1_LOW_PRESSURE) || (B1_ENG_BOT_1_LOW_PRESSURE &amp;&amp; B2_ENG_BOT_1_LOW_PRESSURE)) == 1)) || \
                     (TD(0.2,((A1_ENG_BOT_2_LOW_PRESSURE &amp;&amp; A2_ENG_BOT_2_LOW_PRESSURE) || (B1_ENG_BOT_2_LOW_PRESSURE &amp;&amp; B2_ENG_BOT_2_LOW_PRESSURE)) == 1)) || \
                     (TD(0.2,((A1_BOT_1_R_ENG_SQUIB_FAILED &amp;&amp; A2_BOT_1_R_ENG_SQUIB_FAILED) || (B1_BOT_1_R_ENG_SQUIB_FAILED &amp;&amp; B2_BOT_1_R_ENG_SQUIB_FAILED)) == 1)) || \
                     (TD(0.2,((A1_BOT_2_R_ENG_SQUIB_FAILED &amp;&amp; A2_BOT_2_R_ENG_SQUIB_FAILED) || (B1_BOT_2_R_ENG_SQUIB_FAILED &amp;&amp; B2_BOT_2_R_ENG_SQUIB_FAILED)) == 1)) || \
                     (TD(0.2,((A1_BOT_1_L_ENG_SQUIB_FAILED &amp;&amp; A2_BOT_1_L_ENG_SQUIB_FAILED) || (B1_BOT_1_L_ENG_SQUIB_FAILED &amp;&amp; B2_BOT_1_L_ENG_SQUIB_FAILED)) == 1)) || \
                     (TD(0.2,((A1_BOT_2_L_ENG_SQUIB_FAILED &amp;&amp; A2_BOT_2_L_ENG_SQUIB_FAILED) || (B1_BOT_2_L_ENG_SQUIB_FAILED &amp;&amp; B2_BOT_2_L_ENG_SQUIB_FAILED)) == 1)))'
    
    expr313 = 'Out = (!FWD_CARGO_FIRE_EXT_SYS_ARMED) && (!AFT_CARGO_FIRE_EXT_SYS_ARMED) && \
                     ( (((A1_HRD_LOW_PRESSURE && A2_HRD_LOW_PRESSURE) || (B1_HRD_LOW_PRESSURE && B2_HRD_LOW_PRESSURE)) == 1) || \
                       (((A1_LRD_LOW_PRESSURE && A2_LRD_LOW_PRESSURE) || (B1_LRD_LOW_PRESSURE && B2_LRD_LOW_PRESSURE)) == 1) || \
                       (((A1_CARGO_HRD_SQUIB_FAILED && A2_CARGO_HRD_SQUIB_FAILED) || (B1_CARGO_HRD_SQUIB_FAILED && B2_CARGO_HRD_SQUIB_FAILED)) == 1) || \
                       (((A1_CARGO_FX_FWD_F_V_SQUIB_FAILED && A2_CARGO_FX_FWD_F_V_SQUIB_FAILED) || (B1_CARGO_FX_FWD_F_V_SQUIB_FAILED && B2_CARGO_FX_FWD_F_V_SQUIB_FAILED)) == 1) || \
                       (((A1_CARGO_HRD_SQUIB_FAILED && A2_CARGO_HRD_SQUIB_FAILED) || (B1_CARGO_HRD_SQUIB_FAILED && B2_CARGO_HRD_SQUIB_FAILED)) == 1) || \
                       (((A1_CARGO_FX_FWD_F_V_SQUIB_FAILED && A2_CARGO_FX_FWD_F_V_SQUIB_FAILED) || (B1_CARGO_FX_FWD_F_V_SQUIB_FAILED && B2_CARGO_FX_FWD_F_V_SQUIB_FAILED)) == 1))'
              
    expr = 'A and B and \
            ( (((C and D) or (E and F)) == 1) or \
              (((G and H) or (I and J)) == 1) or \
              (((K and L) or (M and N)) == 1) or \
              (((O and P) or (Q and R)) == 1) or \
              (((K and L) or (M and N)) == 1) or \
              (((O and P) or (Q and R)) == 1))'
              
    expr17 = 'Out = (A1_BLEED_FAULT == 1) || (B1_BLEED_FAULT == 1) || (Inval(A1_LABEL271) &amp;&amp; Inval(B1_LABEL271))'
    expr140 = 'Out = ((RIU_1_ZA_DATA1_L057_ACP_Maintenance_Word_1_SDI == 01b) &amp;&amp; (RIU_1_ZA_DATA1_L057_ACP_Maintenance_Word_1_ACP_Fail_Summary == 1)) || ((RIU_1_ZB_DATA1_L057_ACP_Maintenance_Word_1_SDI == 01b) &amp;&amp; (RIU_1_ZB_DATA1_L057_ACP_Maintenance_Word_1_ACP_Fail_Summary == 1)) || ((RIU_1_ZA_DATA2_L057_ACP_Maintenance_Word_1_SDI == 01b) &amp;&amp; (RIU_1_ZA_DATA2_L057_ACP_Maintenance_Word_1_ACP_Fail_Summary == 1)) || ((RIU_1_ZB_DATA2_L057_ACP_Maintenance_Word_1_SDI == 01b) &amp;&amp; (RIU_1_ZB_DATA2_L057_ACP_Maintenance_Word_1_ACP_Fail_Summary == 1)) || ((RIU_2_ZA_DATA1_L057_ACP_Maintenance_Word_1_SDI == 01b) &amp;&amp; (RIU_1_ZA_DATA1_L057_ACP_Maintenance_Word_1_ACP_Fail_Summary == 1)) || ((RIU_2_ZB_DATA1_L057_ACP_Maintenance_Word_1_SDI == 01b) &amp;&amp; (RIU_1_ZB_DATA1_L057_ACP_Maintenance_Word_1_ACP_Fail_Summary == 1)) || ((RIU_2_ZA_DATA2_L057_ACP_Maintenance_Word_1_SDI == 01b) &amp;&amp; (RIU_1_ZA_DATA2_L057_ACP_Maintenance_Word_1_ACP_Fail_Summary == 1)) || ((RIU_2_ZB_DATA2_L057_ACP_Maintenance_Word_1_SDI == 01b) &amp;&amp; (RIU_1_ZB_DATA2_L057_ACP_Maintenance_Word_1_ACP_Fail_Summary == 1))'

    expr = '(A and B) or (C and D) or (E and B) or (F and D)'

    exprnorm, uniquevars, coupled, varlist, alphabetlist = canonicalize(expr140)
    print exprnorm
    maskdict = findMasking(exprnorm)
    tlist, flist = genTruthTableBrutal(exprnorm, uniquevars, alphabetlist, maskdict)
    print 'T'
    print tlist
    print 'F'
    print flist

    '''
    alerts = parseAlert("../test/FDASAlert.xml")
    for alert in alerts:
        print alert.alertid
        print alert.logic
        if '.td' in alert.rpn:
            print 'TD function ignored'
            alert.conditions = [alert.logic]
            alert.booleanlogic = alert.logic
            alert.alphabet = [alert.logic]
            continue
        exprnorm, uniquevars, coupled, varlist, alphabetlist = canonicalize(alert.logic)
        print exprnorm
        print varlist
        print alphabetlist

    rpn1562 = 'CONFIG.MFS_2L_Position 3.0 .fuminus .flt CONFIG.MFS_2R_Position 3.0 .fuminus .flt .or CONFIG.MFS_3L_Position 3.0 .fuminus .flt .or CONFIG.MFS_3R_Position 3.0 .fuminus .flt .or CONFIG.MFS_4L_Position 3.0 .fuminus .flt .or CONFIG.MFS_4R_Position 3.0 .fuminus .flt .or CONFIG.MFS_5L_Position 3.0 .fuminus .flt .or CONFIG.MFS_5R_Position 3.0 .fuminus .flt .or CONFIG.Left_Gnd_Spoiler_Position .or CONFIG.Right_Gnd_Spoiler_Position .or CONFIG.Speedbrake_Lever_Position 1.28 .fgt .or CONFIG.All_Gear_WOW CONFIG.L_FADEC_Selected_TRA_Filtered 59.0 .fgt CONFIG.R_FADEC_Selected_TRA_Filtered 59.0 .fgt .and .and CONFIG.Voted_Calibrated_Airspeed CONFIG.V1_Critical_Failure_Speed .fle .and .and'
    tlist, flist = genMCDCTable(rpn1562)
    #print tlist, flist
    tprintable = listprint(tlist)
    fprintable = listprint(flist)
    print tprintable
    print fprintable
    '''

    