import re
import sys

from lxml import etree
from openpyxl import Workbook, load_workbook
from openpyxl.cell import get_column_letter, coordinate_from_string, column_index_from_string
from openpyxl.styles import Color, Font, Side, Border, PatternFill, Style, Alignment
from alertExpression import compileToPostfix

yellow   = Color(rgb='00ffff00')
blue   = Color(rgb='00ffff')

thinline = Side(style='thin')
thinborder   = Border(left=thinline, right=thinline, top=thinline, bottom=thinline)

hdrstyle = Style(
    font=Font(b=True),
    fill=PatternFill(patternType='solid', bgColor=yellow, fgColor=yellow),
    border=thinborder
)

refidstyle = Style(
    font=Font(b=True),
    fill=PatternFill(patternType='solid', bgColor=blue, fgColor=blue),
    border=thinborder
)

normstyle=Style(border=thinborder)

class Bunch(object):
    def __init__(self, **kwds):
        self.__dict__.update(kwds)

def parseAlert(fullxmlname):
    ''' 
    parse alert definition, which generated by FDASGen tool chain, and create a T/F table for CD or MC/DC
    Parameters: 
        fullxmlname: full path of the xml file 
    Returns: 
        T/F table in Excel format
    '''
    
    xmltree = etree.parse(fullxmlname)
    root = xmltree.getroot()
    
    alerts = []
    #logics = []
    #rpnlist = []
    
    for x in root.iterfind("alerts/alert"):
        alertid        = x.attrib['alertId']
        sourceid       = x.attrib['sourceId']
        inhibit        = x.attrib['flightPhaseInhibit']

        logicsource = x.find("logicsource")
        logic = x.find("logic")
        #logics.append(logicsource.text.strip())
        #rpnlist.append(logic.text.strip())
        alerts.append(Bunch(sourceid=sourceid, alertid=alertid, inhibit=inhibit, logic=logicsource.text.strip(), rpn=logic.text.strip()))
    
    return alerts #logics, rpnlist    

def genExcelSheet(wb, title, data):
    ws = wb.create_sheet(title=title)
    for rec in data:
        try:
            ws.append(rec)
        except:
            print rec
    
    # set column width
    maxwidth = {}
    for col in data:
        if len(col) > 1 and not type(col[0]) is bool:
            for colidx in range(1, len(col)):
                letter = get_column_letter(colidx)
                currwidth = len(col[colidx-1])
                if not maxwidth.has_key(letter):
                    maxwidth[letter] = currwidth
                elif maxwidth[letter] < currwidth:
                    maxwidth[letter] = currwidth
                    
    for k, v in maxwidth.iteritems():
        ws.column_dimensions[k].width = v

    # set styles
    rowstyle = hdrstyle
    for row in ws.rows:
        setrowstyle = 0
        for cell in row:
            if setrowstyle:
                cell.style = rowstyle

            if type(cell.value) is bool:
                break

            elif cell.value is not None and re.match('^[oO][uU][tT]\s*=\s*', cell.value.strip()) is not None:
                cell.style = rowstyle
                setrowstyle = 1
            
            elif cell.value is not None and re.match('[a-zA-Z]*-[0-9]*([0-9]*)', cell.value.strip()):
                cell.style = refidstyle
        #rowstyle = normstyle

def genExcelFile(filename, sheets):
    wb = Workbook()
    del wb.worksheets[0]

    for title, data in sheets:
        genExcelSheet(wb, title, data)

    wb.save(filename)
    
def genMCDCTable(logic):
    
    def deep(tokens):
        elem = tokens.pop()

        if elem == '.not':
            elem += tokens.pop()
            
        if elem == '.eq':
            n = tokens.pop()
            p = tokens.pop()
            elem = p + ' ' + elem + ' ' + n
            
        if elem.startswith('.td'):
            elem = tokens.pop()

        if elem == '.or' or elem == '.and' or elem == '.xor':
            rtlist, rflist = deep(tokens)
            ltlist, lflist = deep(tokens)
            if elem == '.or':
                return mergeResultOr(ltlist, lflist, rtlist, rflist)
            elif elem == '.and':
                return mergeResultAnd(ltlist, lflist, rtlist, rflist)
            elif elem == '.xor':
                return mergeResultXor(ltlist, lflist, rtlist, rflist)
            else:
                print "Unknown element %s" % elem
                return
        else:
            return [True], [False]
    
    def mergeResultOr(h_tlist, h_flist, r_tlist, r_flist):
        _t = []
        _f = []
        
        if len(h_flist) > 0:
            fh = h_flist[0]
            for tr in r_tlist:
                if (fh, tr) not in _t:
                    _t.append((fh, tr))
            for fr in r_flist:
                if (fh, fr) not in _f:
                    _f.append((fh, fr))

        if len(r_flist) > 0:
            fr = r_flist[0]
            for th in h_tlist:
                if (th, fr) not in _t:
                    _t.append((th, fr))
            for fh in h_flist:
                if (fh, fr) not in _f:
                    _f.append((fh, fr))
        
        return _t, _f

    def mergeResultAnd(h_tlist, h_flist, r_tlist, r_flist):
        _t = []
        _f = []
        
        if len(h_tlist) > 0:
            th = h_tlist[0]
            for fr in r_flist:
                if (th, fr) not in _f:
                    _f.append((th, fr))
            for tr in r_tlist:
                if (th, tr) not in _t:
                    _t.append((th, tr))

        if len(r_tlist) > 0:
            tr = r_tlist[0]
            for fh in h_flist:
                if (fh, tr) not in _f:
                    _f.append((fh, tr))
            for th in h_tlist:
                if (th, tr) not in _t:
                    _t.append((th, tr))
        
        return _t, _f
    
    tokens = logic.strip().split()
    return deep(tokens)

# refer to LDRA
def genDCTable(logic):
    
    #TODO: not finished yet
    #in LDRA "A or B or C" has different coverage as "(A or B) or C"
    
    gl_tlistH = []
    gl_flistH = []
    gl_tlistR = []
    gl_flistR = []
    lastdecision = ''
    
    def operatorNot(boolexp, decision):
        res = [] 
        decisionfound = 0
        if type(boolexp) is bool:
            return not boolexp
        
        if decision == '.and':
            for b in boolexp:
                if not b:
                    decisionfound = 1
                    res.append(True)
                else:
                    res.append(b)
            
            if not decisionfound:
                return (False, False)
        
        if decision == '.or':
            for b in boolexp:
                if b:
                    decisionfound = 1
                    res.append(False)
                else:
                    res.append(b)

            if not decisionfound:
                return (True, True)
            
        return res

    def decisionOr(tlistH, flistH, tlistR, flistR, nextdecision, blockcondition):
        _t = []
        _f = []
        
        for th in tlistH:
            if len(flistR) > 0:
                fr = flistR[0]
                if (th, fr) not in _t:
                    _t.append((th, fr))

        for fh in flistH:
            if len(flistR) > 0:
                fr = flistR[0]
                if (fh, fr) not in _f:
                    _f.append((fh, fr))
            
        #_t.append((_f[-1][0], operatorNot(_f[-1][1], lastdecision)))

        if not blockcondition and nextdecision == '.or':
            fh = flistH[-1]
            tr = tlistR[0]
            tlistR = tlistR[1:]
            _t.append((fh, tr))

        if not blockcondition:
            fh = flistH[-1]
            for tr in tlistR:
                if not type(tr) is bool:
                    _t.append((fh, tr))
                
        return _t, _f

    def decisionAnd(tlistH, flistH, tlistR, flistR, nextdecision, blockcondition):
        _t = []
        _f = []
        
        for fh in flistH:
            if len(tlistR) > 0:
                tr = tlistR[0]
                if (fh, tr) not in _f:
                    _f.append((fh, tr))

        for th in tlistH:
            if len(tlistR) > 0:
                tr = tlistR[0]
                if (th, tr) not in _t:
                    _t.append((th, tr))

        #_f.append((_t[-1][0], operatorNot(_t[-1][1], lastdecision)))

        if not blockcondition and nextdecision == '.and':
            th = tlistH[-1]
            fr = flistR[0]
            flistR = flistR[1:]
            _f.append((th, fr))
            
        if not blockcondition:
            th = tlistH[-1]
            for fr in flistR:
                if not type(fr) is bool:
                    _f.append((th, fr))
        
        return _t, _f
    
    def getDecisions(exp):
        res = []
        for e in exp:
            if e[0] is '.':
                res.append(e)
        return res

    tokens = logic.strip().split()
    begin = 1
    _tlistH = []
    _flistH = []
    _tlistR = []
    _flistR = []
    inblock = 0
    decisionstack = getDecisions(tokens)
    for token in tokens:
        if token == '(':
            inblock = 1
            continue
        if token == ')':
            inblock = 0
            continue
        if token == '.or':
            decisionstack = decisionstack[1:]
            try:
                nextdecision = decisionstack[0]
            except:
                nextdecision = ''
            if not _tlistR and _tlistH:
                gl_tlistH, gl_flistH = decisionOr(gl_tlistH, gl_flistH, _tlistH, _flistH, nextdecision, inblock)
            elif _tlistR and _tlistH:
                if not gl_tlistH:
                    gl_tlistH, gl_flistH = decisionOr(_tlistH, _flistH, _tlistR, _flistR, nextdecision, inblock)
                else:
                    gl_tlistR, gl_flistR = decisionOr(_tlistH, _flistH, _tlistR, _flistR, nextdecision, inblock)
            elif not _tlistH and not _tlistR:
                gl_tlistH, gl_flistH = decisionOr(gl_tlistH, gl_flistH, gl_tlistR, gl_flistR, nextdecision, inblock)
            else:
                pass
            
            lastdecision = '.or'
            _tlistH = []
            _flistH = []
            _tlistR = []
            _flistR = []
            begin = 1
        elif token == '.and':
            decisionstack = decisionstack[1:]
            try:
                nextdecision = decisionstack[0]
            except:
                nextdecision = ''
            if not _tlistR and _tlistH:
                gl_tlistH, gl_flistH = decisionAnd(gl_tlistH, gl_flistH, _tlistH, _flistH, nextdecision, inblock)
            elif _tlistR and _tlistH:
                if not gl_tlistH:
                    gl_tlistH, gl_flistH = decisionAnd(_tlistH, _flistH, _tlistR, _flistR, nextdecision, inblock)
                else:
                    gl_tlistR, gl_flistR = decisionAnd(_tlistH, _flistH, _tlistR, _flistR, nextdecision, inblock)
            elif not _tlistH and not _tlistR:
                gl_tlistH, gl_flistH = decisionAnd(gl_tlistH, gl_flistH, gl_tlistR, gl_flistR, nextdecision, inblock)
            else:
                pass
            
            lastdecision = '.and'
            _tlistH = []
            _flistH = []
            _tlistR = []
            _flistR = []
            begin = 1
        else:
            if not begin:
                _tlistR.append(True)
                _flistR.append(False)
            else:
                _tlistH.append(True)
                _flistH.append(False)
            begin = 0
        
    #print gl_tlistH
    #print gl_flistH
    return gl_tlistH, gl_flistH

def getAllIndex(l, e):
    res = []
    idx = 0
    for _e in l:
        if _e == e:
            res.append(idx)
        elif e in _e:
            res.append(idx)
        idx += 1
    
    return res

def isopposite(c1, c2):
    if '= 0' in c1 and '= 1' in c2:
        return True
    elif '= 1' in c1 and '= 0' in c2:
        return True
    elif '= 0' in c1 and len(c2) == 1:
        return True
    elif len(c1) == 1 and '= 0' in c2:
        return True
    else:
        return False
    
def removeDuplicate(tlist, flist):
    for t in tlist:
        if tlist.count(t) > 1:
            for idx in getAllIndex(tlist, t)[1:]:
                del tlist[idx]
        if flist.count(t) > 0:
            del tlist[tlist.index(t)]
    for f in flist:
        if tlist.count(f) > 0:
            del flist[flist.index(f)]
        if flist.count(f) > 1:
            for idx in getAllIndex(flist, f)[1:]:
                del flist[idx]

def reworkCoupledConditions(l, conditions, coupledconditions):
    for c, idxlist in coupledconditions.iteritems():
        for idx in idxlist[1:]:
            if isopposite(conditions[idxlist[0]], conditions[idx]):
                l[idx] = not l[idxlist[0]]
            else:
                l[idx] = l[idxlist[0]]

def findCoupledCondition(logic, conditions):    
    tokens = logic.strip().split()
    coupledCondition = {}
    for t in tokens:
        if '.active' in logic:
            return coupledCondition
        try:
            int(t) 
            continue
        except:
            pass
        if coupledCondition.has_key(t):
            continue
        elif t.startswith('.'):
            continue
        elif tokens.count(t) > 1:
            coupledCondition[t] = getAllIndex(conditions, t)
    return coupledCondition

def pretyprint(tflist, res):
    if type(tflist) is bool:
        res.append(tflist)
        return

    for tf in tflist:
        pretyprint(tf, res)
        
def listprint(l):
    res = []
    for e in l:
        op=[]
        pretyprint(e, op)
        #print op
        res.append(op)
        
    return res

def getConditions(exp):
    res = []
    for e in exp.split(' '):
        if e == '.not':
            e = res.pop() + ' == 0'
        if e == '.eq':
            n = res.pop()
            p = res.pop()
            e = p + ' == ' + n
        if e.startswith('.td'):
            e = res.pop()
        if not e == '.or' and not e == '.and':
            res.append(e)
    return res

def usage():
    print "Usage of genDCTable.py:"
    print "Input: generated FDAS XML file"
    print "Output: user defined Excel file name"

def main(args):
    if len(args) != 2:
        usage()
        sys.exit(1)
    input_filename  = args[0]
    output_filename = args[1]

    if not input_filename.endswith('.xml'):
        input_filename += '.xml'

    if not output_filename.endswith('.xlsx'):
        output_filename += '.xlsx'

    alerts = parseAlert(input_filename)

    sheet = []
    for alert in alerts:
        #print rpn
        #print rpns[i]
        tlist, flist = genMCDCTable(alert.rpn)
        sheet.append(['%s (%s)' % (alert.sourceid, alert.alertid), alert.inhibit])
        sheet.append([alert.logic])
        conditions = getConditions(alert.rpn)
        sheet.append(conditions)
        #sheet.append(rpns[i].split(' '))
        
        tprintable = listprint(tlist)
        fprintable = listprint(flist)
        
        #coupled condition
        coupledConditions = findCoupledCondition(alert.rpn, conditions)
        if coupledConditions:
            print conditions
            print coupledConditions
            for t in tprintable:
                reworkCoupledConditions(t, conditions, coupledConditions)
            for f in fprintable:
                reworkCoupledConditions(f, conditions, coupledConditions)
            removeDuplicate(tprintable, fprintable)
        
        for t in tprintable:
            t.append(True)
            sheet.append(t)
        for f in fprintable:
            f.append(False)
            sheet.append(f)
        #print ''
        sheet.append([''])
        
    genExcelFile(output_filename,
                    (
                      ("MCDC", sheet), 
                    )
                )
        
if __name__ == "__main__":
    args = sys.argv[1:]
    sys.exit(main(args))
    
    #TESTING
    #alerts = parseAlert("../test/FDAS.xml")

    #rpns = [
    #          'A B .and',
    #          'A B .xor',
    #          'A B .and B C .and .or',
    #          'A B .not .and B 1 .eq C .and .or D B .and .or',
    #          'A B .or',
    #          'A B .and C .and',
    #          'A B .or C .or',
    #          'A B .and C D .and .or',
    #          'A B .or C D .or .and',
    #          'A B .and C .or',
    #          'A B .or C .and',
    #          'A B .or C .or D .or E F .and G .and H .and .or'
    #         ]

    #for l in rpns:
    #    print l
    #    #genMCDCTable(l)
    #    tlist, flist = genMCDCTable(l)
    #    tprintable = listprint(tlist)
    #    fprintable = listprint(flist)
    #    conditions = getConditions(l)
    #    print conditions
    #    coupledConditions = findCoupledCondition(l, conditions)
    #    if coupledConditions:
    #        print coupledConditions
    #        for t in tprintable:
    #            reworkCoupledConditions(t, conditions, coupledConditions)
    #        for f in fprintable:
    #            reworkCoupledConditions(f, conditions, coupledConditions)
    #        print tprintable
    #        print fprintable
    #        removeDuplicate(tprintable, fprintable)
    #        print tprintable
    #        print fprintable
    #    else:
    #        print tprintable
    #        print fprintable
    #    print ''
        